<!DOCTYPE html>
<html lang="en" data-theme="steel-night">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mother of Pearl Generator</title>
    <link rel="stylesheet" href="./theme.css" />
    <style>
        :root {
            --raden-panel-width: 360px;
            --raden-grid-gap: var(--ds-space-3);
            --raden-frame-pad: var(--ds-space-3);
            --raden-section-gap: var(--ds-space-3);
            --raden-row-gap: var(--ds-space-2);
            --raden-row-label-width: 10rem;
        }

        html,
        body {
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            display: grid;
            grid-template-columns: var(--raden-panel-width) 1fr;
            gap: var(--raden-grid-gap);
            padding: var(--raden-frame-pad);
            background:
                radial-gradient(700px 500px at 82% -10%, color-mix(in oklab, var(--ds-accent) 18%, transparent), transparent 70%),
                radial-gradient(800px 600px at -10% 110%, color-mix(in oklab, var(--ds-info) 14%, transparent), transparent 66%),
                var(--ds-bg);
            color: var(--ds-text);
            font-family: var(--ds-font-sans);
        }

        #controls {
            display: grid;
            grid-template-rows: auto minmax(0, 1fr) auto;
            min-height: 0;
            border: var(--ds-border-w) var(--ds-border-style) var(--ds-card-border);
            border-radius: var(--ds-card-radius);
            background: color-mix(in oklab, var(--ds-bg-elevated) 88%, transparent);
            box-shadow: var(--ds-card-shadow);
            backdrop-filter: blur(8px);
        }

        #control-header {
            display: grid;
            gap: var(--ds-space-3);
            padding: var(--ds-space-4);
            border-bottom: var(--ds-border-w) var(--ds-border-style) var(--ds-border);
        }

        #control-scroll {
            min-height: 0;
            overflow: auto;
            display: grid;
            gap: var(--raden-section-gap);
            padding: var(--ds-space-3);
        }

        #controls .section {
            display: grid;
            gap: var(--raden-row-gap);
            padding: var(--ds-space-3);
            border: var(--ds-border-w) var(--ds-border-style) var(--ds-border);
            border-radius: var(--ds-radius-2);
            background: color-mix(in oklab, var(--ds-bg-raised) 86%, transparent);
        }

        #controls .section h3 {
            margin: 0;
            font-size: var(--ds-fs-2);
            letter-spacing: var(--ds-label-spacing);
            text-transform: var(--ds-label-transform);
            color: var(--ds-text-muted);
            font-weight: 600;
        }

        #controls .section[hidden] {
            display: none;
        }

        .control-row {
            display: grid;
            grid-template-columns: minmax(130px, var(--raden-row-label-width)) minmax(0, 1fr) auto;
            align-items: center;
            gap: var(--ds-space-2);
            min-width: 0;
        }

        .control-label {
            position: relative;
            font-size: var(--ds-fs-1);
            letter-spacing: var(--ds-label-spacing);
            text-transform: var(--ds-label-transform);
            color: var(--ds-text-muted);
        }

        .control-label::before {
            content: "â€¢";
            color: var(--ds-warning);
            margin-right: 6px;
            opacity: 0;
            transition: opacity var(--ds-dur-fast) var(--ds-ease-standard);
        }

        .control-label.pending-dot::before {
            opacity: 1;
        }

        .control-input {
            min-width: 0;
            width: 100%;
        }

        .control-icons {
            display: flex;
            justify-content: flex-end;
            min-width: var(--ds-control-h-sm);
        }

        .control-input input[type="number"],
        .control-input select {
            width: 100%;
            min-height: var(--ds-control-h);
            border: var(--ds-border-w) var(--ds-border-style) var(--ds-input-border);
            border-radius: var(--ds-radius-2);
            background: var(--ds-input-bg);
            color: var(--ds-input-text);
            font: inherit;
            padding: var(--ds-space-2) var(--ds-space-3);
        }

        .control-input input[type="range"] {
            width: 100%;
            accent-color: var(--ds-accent);
        }

        .control-input input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--ds-accent);
        }

        .res-inputs {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: var(--ds-space-1);
            width: 100%;
        }

        .res-inputs span {
            color: var(--ds-text-muted);
        }

        .pending-change {
            border-color: var(--ds-warning) !important;
            box-shadow: 0 0 0 1px color-mix(in oklab, var(--ds-warning) 45%, transparent);
        }

        .reset-btn {
            width: var(--ds-control-h-sm);
            min-height: var(--ds-control-h-sm);
            border: var(--ds-border-w) var(--ds-border-style) var(--ds-btn-border);
            border-radius: var(--ds-radius-2);
            background: var(--ds-btn-bg);
            color: var(--ds-btn-text);
            cursor: pointer;
            font: inherit;
            font-size: var(--ds-fs-1);
            padding: 0;
        }

        .reset-btn:hover {
            background: var(--ds-btn-bg-hover);
            border-color: var(--ds-border-strong);
        }

        .export-row {
            display: flex;
            gap: var(--ds-space-2);
            flex-wrap: wrap;
        }

        .theme-row {
            display: grid;
            gap: 6px;
        }

        .theme-row label {
            font-size: var(--ds-fs-1);
            letter-spacing: var(--ds-label-spacing);
            text-transform: var(--ds-label-transform);
            color: var(--ds-text-muted);
        }

        #themeSelect {
            width: 100%;
            min-height: var(--ds-control-h);
            border: var(--ds-border-w) var(--ds-border-style) var(--ds-input-border);
            border-radius: var(--ds-radius-2);
            background: var(--ds-input-bg);
            color: var(--ds-input-text);
            font: inherit;
            padding: var(--ds-space-2) var(--ds-space-3);
        }

        #control-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--ds-space-2);
            padding: var(--ds-space-3);
            border-top: var(--ds-border-w) var(--ds-border-style) var(--ds-border);
        }

        #status {
            max-width: 68%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-radius: var(--ds-radius-pill);
            border: var(--ds-border-w) var(--ds-border-style) var(--ds-border);
            padding: 4px 10px;
            font-size: var(--ds-fs-1);
            color: var(--ds-text-muted);
        }

        #status[data-state="rendering"] {
            color: var(--ds-info);
            border-color: color-mix(in oklab, var(--ds-info) 62%, var(--ds-border));
            background: color-mix(in oklab, var(--ds-info) 16%, transparent);
        }

        #status[data-state="complete"] {
            color: var(--ds-success);
            border-color: color-mix(in oklab, var(--ds-success) 62%, var(--ds-border));
            background: color-mix(in oklab, var(--ds-success) 16%, transparent);
        }

        #status[data-state="error"] {
            color: var(--ds-danger);
            border-color: color-mix(in oklab, var(--ds-danger) 62%, var(--ds-border));
            background: color-mix(in oklab, var(--ds-danger) 16%, transparent);
        }

        #progress {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            width: 0%;
            background: linear-gradient(90deg, var(--ds-accent), var(--ds-focus));
            z-index: var(--ds-z-toast);
            transition: width var(--ds-dur-fast) linear;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: var(--ds-card-radius);
            border: var(--ds-border-w) var(--ds-border-style) var(--ds-border);
            box-shadow: var(--ds-card-shadow);
            background: var(--ds-bg-raised);
            min-width: 0;
            min-height: 0;
        }

        #debugPanel {
            position: fixed;
            top: var(--ds-space-3);
            right: var(--ds-space-3);
            width: min(340px, 45vw);
            max-height: calc(100vh - (2 * var(--ds-space-3)));
            overflow: auto;
            border: var(--ds-border-w) var(--ds-border-style) var(--ds-border);
            border-radius: var(--ds-radius-2);
            background: color-mix(in oklab, var(--ds-bg-elevated) 88%, transparent);
            color: var(--ds-text);
            font-family: var(--ds-font-mono);
            font-size: var(--ds-fs-1);
            line-height: 1.4;
            padding: var(--ds-space-3);
            pointer-events: none;
            z-index: calc(var(--ds-z-toast) - 1);
            white-space: pre-wrap;
        }

        @media (max-width: 980px) {
            body {
                grid-template-columns: 1fr;
                grid-template-rows: minmax(0, 1fr) minmax(240px, 45vh);
            }

            #canvas {
                grid-row: 1;
            }

            #controls {
                grid-row: 2;
            }
        }
    </style>
</head>

<body>
    <div id="controls">
        <div id="control-header">
            <div class="export-row">
                <button class="ds-btn" onclick="exportPNG()">Export PNG</button>
                <button id="toggleDebugBtn" class="ds-btn" onclick="toggleDebugPanel()">Debug Panel</button>
            </div>
            <div class="theme-row">
                <label for="themeSelect">Theme</label>
                <select id="themeSelect">
                    <option value="steel-night">Steel Night</option>
                    <option value="paper-mint">Paper Mint</option>
                    <option value="amber-terminal">Amber Terminal</option>
                    <option value="neon-grid">Neon Grid</option>
                    <option value="mono-slate">Mono Slate</option>
                    <option value="tech-grid">Tech Grid</option>
                    <option value="skeuo-panel">Skeuo Panel</option>
                    <option value="industrial-terminal">Industrial Terminal</option>
                </select>
            </div>
        </div>
        <div id="control-scroll" class="ds-scroll">

            <div class="section" data-mode="all">
                <div class="control-row">
                    <div class="control-label">Mode</div>
                    <div class="control-input">
                        <select id="modeSelector">
                            <option value="motherofpearl">Mother of Pearl</option>
                            <option value="risograph">Risograph</option>
                            <option value="topography">Topography</option>
                        </select>
                    </div>
                    <div class="control-icons"></div>
                </div>
            </div>
            <!-- 1. SEED & RESOLUTION -->
            <div class="section" data-mode="all">
                <h3>Seed + Resolution</h3>
                <div class="control-row" data-mode="motherofpearl, topography">
                    <div class="control-label">Seed:</div>
                    <div class="control-input">
                        <input id="seed" placeholder="(random)" type="number" />
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Preset:</div>
                    <div class="control-input">
                        <select id="resolutionPreset">
                            <option value="">Auto (Window Size)</option>
                            <option value="1920x1080">HD (1920x1080)</option>
                            <option value="1080x1080">Square (1080x1080)</option>
                            <option value="3840x2160">4K (3840x2160)</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Dimensions:</div>
                    <div class="control-input">
                        <div class="res-inputs">
                            <input type="number" id="renderWidth" min="1" placeholder="Width" />
                            <span>x</span>
                            <input type="number" id="renderHeight" min="1" placeholder="Height" />
                        </div>
                    </div>
                    <div class="control-icons"></div>
                </div>
            </div>


            <!-- 2. PATTERN GEOMETRY -->

            <div class="section" data-mode="motherofpearl, topography">
                <h3>Pattern Geometry</h3>
                <div class="control-row" data-mode="topography">
                    <div class="control-label">Noise Type</div>
                    <div class="control-input">
                        <select id="topoNoiseType">
                            <option value="white">White</option>
                            <option value="simplex">Simplex</option>
                            <option value="value">Value</option>
                            <option value="perlin">Perlin</option>
                        </select>
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row" data-mode="motherofpearl, topography">
                    <div class="control-label">Noise Scale:</div>
                    <div class="control-input">
                        <input type="range" id="scale" min="0.001" max="0.02" step="0.001" value="0.006"
                            data-live="false" />
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row" data-mode="motherofpearl, topography">
                    <div class="control-label">Noise Layers:</div>
                    <div class="control-input">
                        <input type="number" id="layers" min="1" max="5" step="1" value="3" data-live="false" />
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row" data-mode="motherofpearl">
                    <div class="control-label">Flow Mode:</div>
                    <div class="control-input">
                        <select id="flowMode" data-live="false">
                            <option value="circular">Circular</option>
                            <option value="linear">Linear</option>
                        </select>
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row" data-mode="motherofpearl">
                    <div class="control-label">Layer Length:</div>
                    <div class="control-input">
                        <input type="range" id="layerLength" min="0" max="2" step="0.01" value="1" data-live="false" />
                    </div>
                    <div class="control-icons"></div>
                </div>
            </div>

            <!-- 3. COLOR APPEARANCE -->
            <div class="section" data-mode="motherofpearl">
                <h3>Color Appearance</h3>

                <div class="control-row">
                    <div class="control-label">Color Range:</div>
                    <div class="control-input">
                        <input type="range" id="range" min="0.1" max="1.5" step="0.1" value="1.0" data-live="false" />
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Blend:</div>
                    <div class="control-input">
                        <input type="range" id="blend" min="0.5" max="3" step="0.1" value="1.2" data-live="false" />
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Color Intensity:</div>
                    <div class="control-input">
                        <input type="range" id="intensity" min="0" max="200" step="1" value="100" data-live="false" />
                    </div>
                    <div class="control-icons"></div>
                </div>
            </div>


            <!-- 4. LIGHTING -->
            <div class="section" data-mode="motherofpearl">
                <h3>Lighting</h3>

                <div class="control-row">
                    <div class="control-label">Light Angle:</div>
                    <div class="control-input">
                        <input type="range" id="lightAngle" min="0" max="1" step="0.01" value="0.5" data-live="false" />
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Highlight Strength:</div>
                    <div class="control-input">
                        <input type="range" id="highlightStrength" min="0" max="2" step="0.01" value="0.5"
                            data-live="false" />
                    </div>
                    <div class="control-icons"></div>
                </div>
            </div>


            <div class="section" data-mode="motherofpearl">
                <h3>Animation</h3>

                <div class="control-row">
                    <div class="control-label">Animate Flow:</div>
                    <div class="control-input">
                        <select id="animateFlow" disabled>
                            <option value="none">None</option>
                            <option value="light">Light Sweep</option>
                            <option value="layers">Wave Layers</option>
                        </select>
                    </div>
                    <div class="control-icons"></div>
                </div>
            </div>

            <!-- 8. ACTIONS -->
            <div class="section" data-mode="risograph">
                <h3>Risograph Controls</h3>

                <div class="control-row">
                    <div class="control-label">Dot Size:</div>
                    <div class="control-input">
                        <input type="range" id="risoDotSize" min="1" max="50" value="10">
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Threshold:</div>
                    <div class="control-input">
                        <input type="range" id="risoThreshold" min="0" max="255" value="128">
                    </div>
                    <div class="control-icons"></div>
                </div>
            </div>

            <!-- 9. ACTIONS -->
            <div class="section" data-mode="topography">
                <h3>Topography</h3>

                <div class="control-row">
                    <div class="control-label">Bands:</div>
                    <div class="control-input">
                        <input type="number" id="topoBandCount" min="2" max="20" step="1" value="8" data-live="false">
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Mode:</div>
                    <div class="control-input">
                        <select id="topoRenderMode" data-live="false">
                            <option value="lines">Lines Only</option>
                            <option value="fill">Band Fill</option>
                            <option value="gradient">Smooth Gradient</option>
                        </select>
                    </div>
                    <div class="control-icons"></div>
                </div>
            </div>
            <!-- 5. POST-PROCESSING -->
            <div class="section" data-mode="all">
                <h3>Post-Processing</h3>

                <div class="control-row">
                    <div class="control-label">Red Boost:</div>
                    <div class="control-input">
                        <input type="range" id="boostR" min="0" max="2" step="0.01" value="1"
                            oninput="adjustColorBoosts()" data-live="true" />
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Green Boost:</div>
                    <div class="control-input">
                        <input type="range" id="boostG" min="0" max="2" step="0.01" value="1"
                            oninput="adjustColorBoosts()" data-live="true" />
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Blue Boost:</div>
                    <div class="control-input">
                        <input type="range" id="boostB" min="0" max="2" step="0.01" value="1"
                            oninput="adjustColorBoosts()" data-live="true" />
                    </div>
                    <div class="control-icons"></div>
                </div>

                <div class="control-row">
                    <div class="control-label">Grain Overlay:</div>
                    <div class="control-input">
                        <input type="checkbox" id="grainToggle" checked />
                    </div>
                    <div class="control-icons"></div>
                </div>
            </div>

        </div>
        <div id="control-footer">
            <div id="status" data-state="idle">Idle</div>
            <button id="generateBtn" class="ds-btn ds-btn-primary" onclick="startGeneration()">Generate</button>
        </div>
    </div>

    <div id="debugPanel">
    </div>

    <div id="progress"></div>
    <canvas id="canvas"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
    <script>

        let debugVisible = true;

        function showDebugInfo(config, extras = {}) {
            const panel = document.getElementById("debugPanel");
            if (!panel) return;

            if (!debugVisible) {
                panel.style.display = "none";
                return;
            }

            let info = "Debug Info\n";
            for (const [key, val] of Object.entries(config)) {
                info += `${key}: ${val}\n`;
            }

            for (const [key, val] of Object.entries(extras)) {
                info += `${key}: ${val}\n`;
            }

            panel.innerText = info;
            panel.style.display = "block";
        }

        function toggleDebugPanel() {
            debugVisible = !debugVisible;
            const panel = document.getElementById("debugPanel");
            const toggleBtn = document.getElementById("toggleDebugBtn");
            if (panel) {
                panel.style.display = debugVisible ? "block" : "none";
            }
            if (toggleBtn) {
                toggleBtn.textContent = debugVisible ? "Hide Debug" : "Show Debug";
            }
        }

        function seededRandom(seed) {
            let x = Math.sin(seed) * 10000;
            return () => {
                x = Math.sin(x) * 10000;
                return x - Math.floor(x);
            };
        }

        function createSeededSimplex(seed) {
            const rng = seededRandom(seed);
            return new SimplexNoise(rng);
        }

        function getInput(id, asInteger = false) {
            const val = document.getElementById(id).value;
            return asInteger ? parseInt(val, 10) : parseFloat(val);
        }


        const generateBtn = document.getElementById("generateBtn");
        // Cached DOM elements for live updates or toggles
        const boostRInput = document.getElementById("boostR");
        const boostGInput = document.getElementById("boostG");
        const boostBInput = document.getElementById("boostB");
        const grainToggle = document.getElementById("grainToggle");
        const highlightStrengthInput = document.getElementById("highlightStrength");
        const themeSelect = document.getElementById("themeSelect");


        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        const offscreenCanvas = document.createElement("canvas");
        const offscreenCtx = offscreenCanvas.getContext("2d");

        const progress = document.getElementById("progress");
        const status = document.getElementById("status");

        function setStatus(state, message) {
            status.dataset.state = state;
            status.textContent = message;
        }

        let simplex;
        let renderTask = null;
        let originalImageData = null;
        let animationId = null;

        function computeLightInfluence(nx, ny, lightVec, highlightStrength) {
            const angleInfluence = nx * lightVec.x + ny * lightVec.y;
            const bandFreq = 10;
            const band = Math.sin((nx * lightVec.y - ny * lightVec.x) * bandFreq * Math.PI);
            const highlightBoost = band * highlightStrength;
            return { angleInfluence, highlightBoost };
        }

        function getFlowCoordinates(x, y, cx, cy, flowMode, layerLength) {
            let px = x, py = y;
            if (flowMode === "circular") {
                const dx = x - cx;
                const dy = y - cy;
                const theta = Math.atan2(dy, dx);
                px += Math.cos(theta) * layerLength * 40;
                py += Math.sin(theta) * layerLength * 40;
            } else if (flowMode === "linear") {
                px += layerLength * 40;
            }
            return { px, py };
        }

        function getNoiseValue(px, py, layers, scale, simplex) {
            let total = 0;
            let totalAmp = 0;
            for (let o = 0; o < layers; o++) {
                const freq = scale * Math.pow(2, o);
                const amp = Math.pow(0.5, o);
                total += simplex.noise2D(px * freq, py * freq) * amp;
                totalAmp += amp;
            }
            return total / totalAmp;
        }

        function getNoiseFunction(type, simplex) {
            switch (type) {
                case "simplex":
                    return (x, y) => simplex.noise2D(x, y); // Already in [-1, 1]
                case "white":
                    return (x, y) => Math.random() * 2 - 1;
                case "value":
                    return (x, y) => {
                        const sx = Math.floor(x * 1000) % 1000;
                        const sy = Math.floor(y * 1000) % 1000;
                        const seed = (sx + sy * 57);
                        return (Math.sin(seed) * 43758.5453) % 1 * 2 - 1;
                    };
                default:
                    return (x, y) => 0;
            }
        }

        function getCombinedNoiseFunction(baseFn, layers, scale) {
            return (x, y) => {
                let total = 0;
                let amp = 1;
                let freq = 1;
                let max = 0;
                for (let i = 0; i < layers; i++) {
                    total += baseFn(x * freq * scale, y * freq * scale) * amp;
                    max += amp;
                    amp *= 0.5;
                    freq *= 2;
                }
                return total / max;
            };
        }

        function fract(n) {
            return n - Math.floor(n);
        }

        function getLiveRenderOverrides() {
            return {
                boostR: parseFloat(boostRInput.value),
                boostG: parseFloat(boostGInput.value),
                boostB: parseFloat(boostBInput.value),
                highlightStrength: parseFloat(highlightStrengthInput.value),
                grain: grainToggle.checked
            };
        }

        function blendPaletteColors(value, blendSharpness, colorRange, colorIntensity, palette) {
            const valueClamped = Math.min(1, Math.max(0, value)) * colorRange;
            const scaled = valueClamped * 4;
            const index = Math.max(0, Math.min(Math.floor(scaled), palette.length - 2));
            const frac = Math.pow(scaled - index, blendSharpness);

            const c1 = palette[index];
            const c2 = palette[index + 1];

            let h = c1.h + (c2.h - c1.h) * frac;
            let s = (c1.s + (c2.s - c1.s) * frac) * (colorIntensity / 100);
            let l = c1.l + (c2.l - c1.l) * frac;

            return { h, s, l };
        }

        function applyHueShift(h, nx, ny, lightVec) {
            const directionInfluence = nx * lightVec.y - ny * lightVec.x;
            const hueShift = directionInfluence * 30;
            return (h + hueShift + 360) % 360;
        }

        function writePixel(data, i, r, g, b, boostR, boostG, boostB) {
            data[i] = Math.min(255, r * boostR);
            data[i + 1] = Math.min(255, g * boostG);
            data[i + 2] = Math.min(255, b * boostB);
            data[i + 3] = 255;
        }


        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const k = (n) => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = (n) =>
                l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            return [
                Math.round(f(0) * 255),
                Math.round(f(8) * 255),
                Math.round(f(4) * 255),
            ];
        }

        const palette = [
            { h: 290, s: 20, l: 85 },
            { h: 180, s: 20, l: 85 },
            { h: 60, s: 20, l: 90 },
            { h: 330, s: 20, l: 88 },
            { h: 0, s: 0, l: 95 },
        ];

        function updateVisibleSections(mode) {
            const allSections = document.querySelectorAll("#controls .section");
            allSections.forEach(section => {
                const modes = section.dataset.mode
                    ? section.dataset.mode.split(",").map(s => s.trim())
                    : ["all"];
                const shouldShow = modes.includes("all") || modes.includes(mode);
                section.hidden = !shouldShow;
            });

            const allRows = document.querySelectorAll("#controls .control-row");
            allRows.forEach(row => {
                const modes = row.dataset.mode
                    ? row.dataset.mode.split(",").map(s => s.trim())
                    : ["all"];
                const shouldShow = modes.includes("all") || modes.includes(mode);
                row.hidden = !shouldShow;
            });
        }

        function markControlPending(el) {
            el.classList.add("pending-change");
            const controlRow = el.closest(".control-row");
            if (!controlRow) return;

            const label = controlRow.querySelector(".control-label");
            if (label) {
                label.classList.add("pending-dot");
            }
        }

        document.getElementById("resolutionPreset").addEventListener("change", () => {
            const preset = document.getElementById("resolutionPreset").value;
            const wInput = document.getElementById("renderWidth");
            const hInput = document.getElementById("renderHeight");

            if (preset && preset !== "custom") {
                const [w, h] = preset.split("x").map(Number);
                if (parseInt(wInput.value) !== w || parseInt(hInput.value) !== h) {
                    wInput.value = w;
                    hInput.value = h;
                    markControlPending(wInput);
                    markControlPending(hInput);
                }
            } else {
                wInput.value = "";
                hInput.value = "";
                markControlPending(wInput);
                markControlPending(hInput);
            }
            updatePendingStatus();
        });

        function applyGrainOverlay(ctx, width, height) {
            const grainImage = ctx.getImageData(0, 0, width, height);
            const d = grainImage.data;

            for (let i = 0; i < d.length; i += 4) {
                const grain = Math.floor((Math.random() - 0.5) * 20); // range -10 to +10
                d[i] = Math.min(255, Math.max(0, d[i] + grain)); // R
                d[i + 1] = Math.min(255, Math.max(0, d[i + 1] + grain)); // G
                d[i + 2] = Math.min(255, Math.max(0, d[i + 2] + grain)); // B
            }

            ctx.putImageData(grainImage, 0, 0);
        }
        function getRenderConfig() {
            const seed = getInput("seed", true);

            return {
                width: getInput("renderWidth", true) || window.innerWidth,
                height: getInput("renderHeight", true) || window.innerHeight,
                seed,
                layers: getInput("layers", true),
                scale: getInput("scale"),
                blend: getInput("blend"),
                layerLength: getInput("layerLength"),
                colorIntensity: getInput("intensity"),
                colorRange: getInput("range"),
                flowMode: document.getElementById("flowMode").value,
                highlightStrength: getInput("highlightStrength"),
                lightAngle: getInput("lightAngle"),
                animateFlow: document.getElementById("animateFlow").value,
                dotSize: getInput("risoDotSize", true),
                threshold: getInput("risoThreshold", true),
                boostR: getInput("boostR"),
                boostG: getInput("boostG"),
                boostB: getInput("boostB"),
                grain: document.getElementById("grainToggle").checked
            };
        }

        function startGeneration(force = false) {
            const mode = document.getElementById("modeSelector").value;

            switch (mode) {
                case "motherofpearl":
                    generateMotherOfPearl(force);
                    break;
                case "risograph":
                    generateRisograph(force);
                    break;
                case "topography":
                    generateTopography(force);
                    break;
                default:
                    console.warn("Unknown mode:", mode);
                    break;
            }
        }

        function generateMotherOfPearl(force = false) {
            clearPendingIndicators();

            if (renderTask || (animationId && !force)) return;

            const config = getRenderConfig();

            if (!Array.isArray(palette) || palette.length < 2) {
                console.error("Palette must be an array with at least 2 colors.");
                setStatus("error", "Palette error");
                return;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
                generateBtn.disabled = false;
            }

            if (renderTask) return;

            canvas.width = config.width;
            canvas.height = config.height;
            offscreenCanvas.width = config.width;
            offscreenCanvas.height = config.height;

            simplex = createSeededSimplex(config.seed);

            const layers = config.layers;

            const cx = config.width / 2;
            const cy = config.height / 2;
            const imageData = offscreenCtx.createImageData(config.width, config.height);
            const data = imageData.data;

            const scale = config.scale;
            const blendSharpness = config.blend;
            const layerLength = config.layerLength;
            const colorIntensity = config.colorIntensity;
            const colorRange = config.colorRange;
            const highlightStrength = config.highlightStrength;
            const lightAngle = config.lightAngle;

            const flowMode = config.flowMode;
            const animateFlow = config.animateFlow;

            const boostR = config.boostR;
            const boostG = config.boostG;
            const boostB = config.boostB;


            const lightVec = {
                x: Math.cos(lightAngle * 2 * Math.PI),
                y: Math.sin(lightAngle * 2 * Math.PI),
            };

            showDebugInfo(config);


            let y = 0;
            const rowsPerFrame = 10;
            setStatus("rendering", "Rendering...");
            generateBtn.disabled = true;

            progress.style.width = "0%";

            function renderChunk() {
                const endY = Math.min(y + rowsPerFrame, config.height);
                for (; y < endY; y++) {
                    for (let x = 0; x < config.width; x++) {
                        const nx = x / config.width - 0.5;
                        const ny = y / config.height - 0.5;

                        const { angleInfluence, highlightBoost } = computeLightInfluence(nx, ny, lightVec, highlightStrength);
                        const { px, py } = getFlowCoordinates(x, y, cx, cy, flowMode, layerLength);
                        const noise = getNoiseValue(px, py, layers, scale, simplex);

                        const value = (noise + angleInfluence * 1.5 + highlightBoost + 1) / 2;
                        const { h, s, l } = blendPaletteColors(value, blendSharpness, colorRange, colorIntensity, palette);
                        const shiftedHue = applyHueShift(h, nx, ny, lightVec);

                        const [r, g, b] = hslToRgb(shiftedHue, s, l);
                        const i = (y * config.width + x) * 4;

                        writePixel(data, i, r, g, b, boostR, boostG, boostB);
                    }
                }
                progress.style.width = `${(y / config.height) * 100}%`;
                if (y < config.height) {
                    requestAnimationFrame(renderChunk);
                } else {
                    offscreenCtx.putImageData(imageData, 0, 0);

                    // Apply a soft blur before compositing
                    ctx.clearRect(0, 0, config.width, config.height);
                    ctx.globalAlpha = 1;
                    ctx.drawImage(offscreenCanvas, 0, 0);

                    // Overlay blurred glow layer
                    ctx.globalAlpha = 0.2;
                    ctx.filter = "blur(8px)";
                    ctx.drawImage(offscreenCanvas, 0, 0);

                    // Reset effects
                    ctx.globalAlpha = 1.0;
                    ctx.filter = "none";

                    if (config.grain) {
                        applyGrainOverlay(ctx, config.width, config.height);
                    }

                    originalImageData = new ImageData(
                        new Uint8ClampedArray(imageData.data),
                        imageData.width,
                        imageData.height
                    );

                    setStatus("complete", "Complete");

                    setTimeout(() => {
                        setStatus("idle", "Idle");
                        generateBtn.disabled = false;
                    }, 500);

                    renderTask = null;
                    // Save current values as "applied"
                    document.querySelectorAll('#controls input, #controls select').forEach(el => {
                        if (el.dataset.live !== "true") {
                            el.dataset.applied = el.type === "checkbox" ? String(el.checked) : el.value;
                        }
                    });

                }
            }
            renderTask = renderChunk;
            requestAnimationFrame(renderChunk);
        }

        function generateRisograph(force = false) {
            clearPendingIndicators();
            generateBtn.disabled = true;

            const width = canvas.width;
            const height = canvas.height;

            const config = getRenderConfig();
            const dotSize = config.dotSize;
            const threshold = config.threshold;

            // Read pixel data from existing canvas content
            const imageData = ctx.getImageData(0, 0, width, height).data;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            for (let y = 0; y < height; y += dotSize) {
                for (let x = 0; x < width; x += dotSize) {
                    const i = (y * width + x) * 4;
                    const r = imageData[i];
                    const g = imageData[i + 1];
                    const b = imageData[i + 2];

                    // Calculate perceived brightness (standard grayscale conversion)
                    const brightness = 0.299 * r + 0.587 * g + 0.114 * b;

                    if (brightness < threshold) {
                        ctx.fillStyle = "#000";
                        ctx.beginPath();
                        ctx.arc(x, y, dotSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            originalImageData = ctx.getImageData(0, 0, config.width, config.height);

            const { boostR, boostG, boostB, grain } = getLiveRenderOverrides();
            adjustColorBoosts();
            if (grain) applyGrainOverlay(ctx, config.width, config.height);

            setTimeout(() => {
                setStatus("complete", "Riso rendered");
                generateBtn.disabled = false;
                setTimeout(() => setStatus("idle", "Idle"), 500);
            }, 800);

        }

        function generateTopography(force = false) {
            clearPendingIndicators();
            generateBtn.disabled = true;

            const config = getRenderConfig();
            const bandCount = getInput("topoBandCount", true);
            const renderMode = document.getElementById("topoRenderMode").value;
            const noiseType = document.getElementById("topoNoiseType").value;

            simplex = createSeededSimplex(config.seed);
            const baseNoise = getNoiseFunction(noiseType, simplex);
            const effectiveScale = 1000 * config.scale;

            const noiseFunc = getCombinedNoiseFunction(baseNoise, config.layers, effectiveScale);

            showDebugInfo(config, { effectiveScale });

            canvas.width = config.width;
            canvas.height = config.height;

            const imageData = ctx.createImageData(config.width, config.height);
            const data = imageData.data;

            for (let y = 0; y < config.height; y++) {
                for (let x = 0; x < config.width; x++) {
                    const i = (y * config.width + x) * 4;
                    const nx = x / config.width;
                    const ny = y / config.height;

                    const value = (noiseFunc(nx, ny) + 1) / 2; // Normalize to [0,1]
                    const band = Math.floor(value * bandCount);

                    let color = 255;
                    if (renderMode === "lines") {
                        // Check neighbors and highlight if band changes
                        const vRight = (noiseFunc((x + 1) / config.width, ny) + 1) / 2;
                        const vDown = (noiseFunc(nx, (y + 1) / config.height) + 1) / 2;
                        const bRight = Math.floor(vRight * bandCount);
                        const bDown = Math.floor(vDown * bandCount);
                        color = (band !== bRight || band !== bDown) ? 0 : 255;
                    } else if (renderMode === "fill") {
                        color = Math.floor((band / (bandCount - 1)) * 255);
                    } else if (renderMode === "gradient") {
                        color = Math.floor(value * 255);
                    }

                    data[i] = data[i + 1] = data[i + 2] = color;
                    data[i + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            originalImageData = ctx.getImageData(0, 0, config.width, config.height);


            // Post-processing
            const { grain } = getLiveRenderOverrides();
            if (grain) applyGrainOverlay(ctx, config.width, config.height);
            adjustColorBoosts();

            setStatus("complete", `Topography rendered: ${bandCount} bands, ${renderMode}`);

            setTimeout(() => {
                setStatus("idle", "Idle");
                generateBtn.disabled = false;
            }, 800);
        }

        function updatePendingStatus() {
            const pendingCount = document.querySelectorAll('.pending-change').length;

            if (status.dataset.state === "idle") {
                if (pendingCount > 0) {
                    setStatus("idle", `Idle: ${pendingCount} change${pendingCount > 1 ? "s" : ""} not applied`);
                } else {
                    setStatus("idle", "Idle");
                }
            }
        }

        function clearPendingIndicators() {
            document.querySelectorAll('#controls input, #controls select').forEach(el => {
                el.classList.remove('pending-change');
                if (el.dataset.live !== "true") {
                    el.dataset.applied = el.type === "checkbox" ? String(el.checked) : el.value;
                }

                const controlRow = el.closest(".control-row");
                if (controlRow) {
                    const label = controlRow.querySelector(".control-label");
                    if (label) label.classList.remove("pending-dot");
                }
            });

            document.querySelectorAll('.reset-btn').forEach(btn => btn.remove());

            updatePendingStatus();
        }


        function adjustColorBoosts() {
            if (!originalImageData) return;

            const { boostR, boostG, boostB } = getLiveRenderOverrides();

            const width = originalImageData.width;
            const height = originalImageData.height;

            const originalData = originalImageData.data;
            const newImageData = ctx.createImageData(width, height);
            const newData = newImageData.data;

            for (let i = 0; i < originalData.length; i += 4) {
                newData[i] = Math.min(255, originalData[i] * boostR); // R
                newData[i + 1] = Math.min(255, originalData[i + 1] * boostG); // G
                newData[i + 2] = Math.min(255, originalData[i + 2] * boostB); // B
                newData[i + 3] = originalData[i + 3]; // A
            }

            ctx.putImageData(newImageData, 0, 0);
        }

        function updateLightingEffect(lightAngle) {
            if (!originalImageData) return;

            const width = originalImageData.width;
            const height = originalImageData.height;

            const data = originalImageData.data;
            const newImageData = ctx.createImageData(width, height);
            const newData = newImageData.data;

            const { highlightStrength } = getLiveRenderOverrides();

            const lightVec = {
                x: Math.cos(lightAngle * 2 * Math.PI),
                y: Math.sin(lightAngle * 2 * Math.PI),
            };

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;

                    const nx = x / width - 0.5;
                    const ny = y / height - 0.5;
                    const bandFreq = 10;
                    const band = Math.sin(
                        (nx * lightVec.y - ny * lightVec.x) * bandFreq * Math.PI
                    );
                    const highlight = band * highlightStrength;

                    newData[i] = Math.min(255, data[i] + highlight * 255);
                    newData[i + 1] = Math.min(255, data[i + 1] + highlight * 255);
                    newData[i + 2] = Math.min(255, data[i + 2] + highlight * 255);
                    newData[i + 3] = data[i + 3];
                }
            }

            ctx.putImageData(newImageData, 0, 0);
        }

        function exportPNG() {
            const link = document.createElement("a");
            const mode = document.getElementById("modeSelector").value;
            link.download = `${mode}_output.png`;
            link.href = canvas.toDataURL("image/png");
            link.click();
        }

        document.addEventListener("DOMContentLoaded", () => {
            const mode = document.getElementById("modeSelector").value;
            document.body.setAttribute("data-mode", mode);
            updateVisibleSections(mode);
            setStatus("idle", "Idle");

            const savedTheme = localStorage.getItem("raden-theme") || document.documentElement.dataset.theme || "steel-night";
            document.documentElement.dataset.theme = savedTheme;
            if (themeSelect) themeSelect.value = savedTheme;

            document.querySelectorAll("#controls input, #controls select").forEach((el) => {
                if (el.dataset.live !== "true") {
                    el.dataset.applied = el.type === "checkbox" ? String(el.checked) : el.value;
                }
            });

            updatePendingStatus();
            startGeneration();
        });

        document.getElementById("modeSelector").addEventListener("change", (e) => {
            const mode = e.target.value;
            document.body.setAttribute("data-mode", mode);
            console.log("Switched to mode:", mode);
            updateVisibleSections(mode);
            // Later: Show/hide relevant controls based on mode
        });

        if (themeSelect) {
            themeSelect.addEventListener("change", (e) => {
                const selectedTheme = e.target.value;
                document.documentElement.dataset.theme = selectedTheme;
                localStorage.setItem("raden-theme", selectedTheme);
            });
        }

        document.querySelectorAll("#controls input, #controls select").forEach((el) => {
            if (el.dataset.live !== "true") {
                el.addEventListener("input", () => {
                    markControlPending(el);

                    const controlRow = el.closest(".control-row");
                    if (!controlRow) return;
                    const icons = controlRow.querySelector(".control-icons");
                    if (icons && !icons.querySelector(".reset-btn")) {
                        const btn = document.createElement("button");
                        btn.innerText = "R";
                        btn.className = "reset-btn";
                        btn.title = "Revert to last applied";

                        btn.onclick = (e) => {
                            e.preventDefault();
                            if (el.type === "checkbox") {
                                el.checked = el.dataset.applied === "true";
                            } else {
                                el.value = el.dataset.applied || "";
                            }
                            el.classList.remove("pending-change");

                            const label = controlRow.querySelector(".control-label");
                            if (label) {
                                label.classList.remove("pending-dot");
                            }

                            btn.remove();
                            updatePendingStatus();
                        };

                        icons.appendChild(btn);
                    }

                    updatePendingStatus();
                });
            }
        });
    </script>
</body>

</html>


