<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Mother of Pearl Generator</title>
    <style>
        html,
        body {
            margin: 0;
            background: #111;
            color: #fff;
            font-family: sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 1rem;
            border-radius: 8px;
            z-index: 10;
            max-height: 95vh;
            overflow-y: auto;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 0.4rem 0.8rem;
            align-items: center;
        }

        #controls label {
            grid-column: 1 / span 2;
            display: contents;
        }

        #controls input[type="range"],
        #controls input[type="number"],
        #controls select {
            grid-column: 2;
            width: 150px;
        }

        #controls input[data-live="true"] {
            border: 1px solid #8f8;
            box-shadow: 0 0 3px #8f8a;
        }

        #controls span.label {
            grid-column: 1;
        }

        #controls .button-row {
            grid-column: 1 / span 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        #controls .export-row {
            grid-column: 1 / span 2;
            margin-top: 0.5rem;
        }

        button {
            padding: 4px 10px;
        }

        #controls .res-inputs {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            grid-column: 2;
        }

        #controls .res-inputs input[type="number"] {
            width: 60px;
        }



        #status {
            font-size: 0.9rem;
            padding: 2px 6px;
            border-radius: 4px;
            min-width: 70px;
            text-align: center;
            transition: background 0.3s, color 0.3s;
        }

        #controls .status {
            font-size: 0.9rem;
            padding: 2px 8px;
            border-radius: 6px;
            display: inline-block;
            font-weight: bold;
            color: #fff;
        }

        #controls .status.idle {
            background-color: #444;
            color: #ccc;
        }

        #controls .status.rendering {
            background-color: #2255aa;
            color: #fff;
        }

        #controls .status.complete {
            background-color: #2d8030;
            color: #fff;
        }


        /* Idle state */
        #status.idle {
            background: #222;
            color: #ccc;
            border: 1px solid #444;
        }

        /* Rendering state */
        #status.rendering {
            background: #448;
            color: #fff;
            border: 1px solid #88f;
            animation: pulse 1s infinite ease-in-out;
        }

        /* Pulse animation */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 5px #88f8;
            }

            50% {
                box-shadow: 0 0 12px #88f;
            }

            100% {
                box-shadow: 0 0 5px #88f8;
            }
        }


        #progress {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: #88f;
            width: 0%;
            z-index: 20;
        }

        #controls .section {
            grid-column: 1 / span 2;
            display: contents;
            /* NEW: this preserves grid behavior */
            margin-top: 1rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #controls .section h3 {
            grid-column: 1 / span 2;
            font-size: 1rem;
            margin: 0 0 0.4rem 0;
            color: #aaa;
            font-weight: normal;
        }
    </style>
</head>

<body>
    <div id="controls">
        <!-- 1. SEED & RESOLUTION -->
        <div class="section">
            <span class="label">Seed:</span>
            <input type="number" id="seed" placeholder="(random)">
            <h3>Resolution</h3>

            <span class="label">Preset:</span>
            <select id="resolutionPreset">
                <option value="">Auto (Window Size)</option>
                <option value="1920x1080">HD (1920×1080)</option>
                <option value="1080x1080">Square (1080×1080)</option>
                <option value="3840x2160">4K (3840×2160)</option>
                <option value="custom">Custom</option>
            </select>

            <span class="label">Dimensions:</span>
            <div class="res-inputs">
                <input type="number" id="renderWidth" min="1" placeholder="Width">
                <span>×</span>
                <input type="number" id="renderHeight" min="1" placeholder="Height">
            </div>
        </div>


        <!-- 2. PATTERN GEOMETRY -->
        <div class="section">
            <h3>Pattern Geometry</h3>
            <span class="label">Noise Scale:</span><input type="range" id="scale" min="0.001" max="0.02" step="0.001"
                value="0.006">
            <span class="label">Noise Layers:</span><input type="number" id="layers" min="1" max="5" step="1" value="3">
            <span class="label">Flow Mode:</span>
            <select id="flowMode">
                <option value="circular">Circular</option>
                <option value="linear">Linear</option>
            </select>
            <span class="label">Layer Length:</span><input type="range" id="layerLength" min="0" max="2" step="0.01"
                value="1">
        </div>

        <!-- 3. COLOR APPEARANCE -->
        <div class="section">
            <h3>Color Appearance</h3>
            <span class="label">Color Range:</span><input type="range" id="range" min="0.1" max="1.5" step="0.1"
                value="1.0">
            <span class="label">Blend:</span><input type="range" id="blend" min="0.5" max="3" step="0.1" value="1.2">
            <span class="label">Color Intensity:</span><input type="range" id="intensity" min="0" max="200" step="1"
                value="100">
        </div>

        <!-- 4. LIGHTING -->
        <div class="section">
            <h3>Lighting</h3>
            <span class="label">Light Angle:</span><input type="range" id="lightAngle" min="0" max="1" step="0.01"
                value="0.5">
            <span class="label">Highlight Strength:</span><input type="range" id="highlightStrength" min="0" max="2"
                step="0.01" value="0.5">
        </div>

        <!-- 5. POST-PROCESSING -->
        <div class="section">
            <h3>Post-Processing</h3>
            <span class="label">Red Boost:</span><input type="range" id="boostR" min="0" max="2" step="0.01" value="1"
                oninput="adjustColorBoosts()" data-live="true">
            <span class="label">Green Boost:</span><input type="range" id="boostG" min="0" max="2" step="0.01" value="1"
                oninput="adjustColorBoosts()" data-live="true">
            <span class="label">Blue Boost:</span><input type="range" id="boostB" min="0" max="2" step="0.01" value="1"
                oninput="adjustColorBoosts()" data-live="true">
            <span class="label">Grain Overlay:</span><input type="checkbox" id="grainToggle" checked>
        </div>

        <!-- 6. ANIMATION -->
        <div class="section">
            <h3>Animation</h3>
            <span class="label">Animate Flow:</span>
            <select id="animateFlow" disabled>
                <option value="none">None</option>
                <option value="light">Light Sweep</option>
                <option value="layers">Wave Layers</option>
            </select>
        </div>

        <!-- 7. ACTIONS -->
        <div class="section">
            <div class="button-row">
                <button onclick="startGeneration()">Generate</button>
                <div id="status" class="status idle">💤 Idle</div>
            </div>
            <div class="export-row">
                <button onclick="exportPNG()">Export PNG</button>
            </div>
        </div>

    </div>
    <div id="progress"></div>
    <canvas id="canvas"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
    <script>

        function seededRandom(seed) {
            let x = Math.sin(seed) * 10000;
            return () => {
                x = Math.sin(x) * 10000;
                return x - Math.floor(x);
            };
        }

        function createSeededSimplex(seed) {
            const rng = seededRandom(seed);
            return new SimplexNoise(rng);
        }
        const generateBtn = document.querySelector('button[onclick="startGeneration()"]');

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        const offscreenCanvas = document.createElement("canvas");
        const offscreenCtx = offscreenCanvas.getContext("2d");

        const progress = document.getElementById("progress");
        const status = document.getElementById("status");

        let simplex;
        let renderTask = null;
        let originalImageData = null;
        let animationId = null;



        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const k = n => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
        }

        const palette = [
            { h: 290, s: 20, l: 85 },
            { h: 180, s: 20, l: 85 },
            { h: 60, s: 20, l: 90 },
            { h: 330, s: 20, l: 88 },
            { h: 0, s: 0, l: 95 }
        ];

        document.getElementById("resolutionPreset").addEventListener("change", () => {
            const preset = document.getElementById("resolutionPreset").value;
            const wInput = document.getElementById("renderWidth");
            const hInput = document.getElementById("renderHeight");

            if (preset && preset !== "custom") {
                const [w, h] = preset.split("x").map(Number);
                wInput.value = w;
                hInput.value = h;
            } else {
                wInput.value = "";
                hInput.value = "";
            }
        });

        function applyGrainOverlay(ctx, width, height) {
            const grainImage = ctx.getImageData(0, 0, width, height);
            const d = grainImage.data;

            for (let i = 0; i < d.length; i += 4) {
                const grain = Math.floor((Math.random() - 0.5) * 20); // range -10 to +10
                d[i] = Math.min(255, Math.max(0, d[i] + grain));     // R
                d[i + 1] = Math.min(255, Math.max(0, d[i + 1] + grain)); // G
                d[i + 2] = Math.min(255, Math.max(0, d[i + 2] + grain)); // B
            }

            ctx.putImageData(grainImage, 0, 0);
        }

        function startGeneration(force = false) {
            if (renderTask || (animationId && !force)) return;

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
                generateBtn.disabled = false;
            }


            if (renderTask) return;

            const widthInput = document.getElementById("renderWidth").value;
            const heightInput = document.getElementById("renderHeight").value;
            const width = canvas.width = widthInput ? parseInt(widthInput) : window.innerWidth;
            const height = canvas.height = heightInput ? parseInt(heightInput) : window.innerHeight;
            offscreenCanvas.width = width;
            offscreenCanvas.height = height;


            const seedInput = document.getElementById("seed").value;
            const seed = seedInput ? parseInt(seedInput) : Math.floor(Math.random() * 100000);
            simplex = createSeededSimplex(seed);
            document.getElementById("seed").value = seed; // store it visibly

            const layers = parseInt(document.getElementById("layers").value);


            const cx = width / 2;
            const cy = height / 2;
            const imageData = offscreenCtx.createImageData(width, height);
            const data = imageData.data;

            const scale = parseFloat(document.getElementById("scale").value);
            const lightAngle = parseFloat(document.getElementById("lightAngle").value);
            const blendSharpness = parseFloat(document.getElementById("blend").value);
            const layerLength = parseFloat(document.getElementById("layerLength").value);
            const colorIntensity = parseFloat(document.getElementById("intensity").value);
            const colorRange = parseFloat(document.getElementById("range").value);
            const flowMode = document.getElementById("flowMode").value;
            const highlightStrength = parseFloat(document.getElementById("highlightStrength").value);
            const animateFlow = document.getElementById("animateFlow").value;


            const boostR = parseFloat(document.getElementById("boostR").value);
            const boostG = parseFloat(document.getElementById("boostG").value);
            const boostB = parseFloat(document.getElementById("boostB").value);

            const lightVec = {
                x: Math.cos(lightAngle * 2 * Math.PI),
                y: Math.sin(lightAngle * 2 * Math.PI)
            };

            let y = 0;
            const rowsPerFrame = 10;
            status.innerText = "⏳ Rendering...";
            status.className = "status rendering";
            generateBtn.disabled = true;

            progress.style.width = "0%";

            function renderChunk() {
                const endY = Math.min(y + rowsPerFrame, height);
                for (; y < endY; y++) {
                    for (let x = 0; x < width; x++) {
                        const nx = x / width - 0.5;
                        const ny = y / height - 0.5;
                        const angleInfluence = nx * lightVec.x + ny * lightVec.y;
                        // Add highlight banding using light direction
                        const bandFreq = 10;
                        const band = Math.sin((nx * lightVec.y - ny * lightVec.x) * bandFreq * Math.PI);
                        const highlightBoost = band * highlightStrength;

                        let px = x;
                        let py = y;

                        if (flowMode === 'circular') {
                            const dx = x - cx;
                            const dy = y - cy;
                            const theta = Math.atan2(dy, dx);
                            px += Math.cos(theta) * layerLength * 40;
                            py += Math.sin(theta) * layerLength * 40;
                        } else if (flowMode === 'linear') {
                            px += layerLength * 40;
                        }

                        let total = 0;
                        let totalAmp = 0;
                        for (let o = 0; o < layers; o++) {
                            const freq = scale * Math.pow(2, o);
                            const amp = Math.pow(0.5, o);
                            total += simplex.noise2D(px * freq, py * freq) * amp;
                            totalAmp += amp;
                        }
                        const noise = total / totalAmp;
                        const value = (noise + angleInfluence * 1.5 + highlightBoost + 1) / 2;

                        const valueClamped = Math.min(1, Math.max(0, value)) * colorRange;
                        const scaled = valueClamped * 4;
                        const index = Math.min(Math.floor(scaled), palette.length - 2);
                        const frac = Math.pow(scaled - index, blendSharpness);

                        const c1 = palette[index % palette.length];
                        const c2 = palette[(index + 1) % palette.length];

                        let h = c1.h + (c2.h - c1.h) * frac;
                        let s = (c1.s + (c2.s - c1.s) * frac) * (colorIntensity / 100);
                        let l = c1.l + (c2.l - c1.l) * frac;

                        // Apply directional hue shift based on light vector
                        const directionInfluence = nx * lightVec.y - ny * lightVec.x;
                        const hueShift = directionInfluence * 30; // ±30 degrees hue shift
                        h = (h + hueShift + 360) % 360; // wrap hue within 0–360

                        const [r, g, b] = hslToRgb(h, s, l);

                        const i = (y * width + x) * 4;
                        const rAdj = Math.min(255, r * boostR);
                        const gAdj = Math.min(255, g * boostG);
                        const bAdj = Math.min(255, b * boostB);

                        data[i] = rAdj;
                        data[i + 1] = gAdj;
                        data[i + 2] = bAdj;
                        data[i + 3] = 255;
                    }
                }
                progress.style.width = `${(y / height) * 100}%`;
                if (y < height) {
                    requestAnimationFrame(renderChunk);
                } else {
                    offscreenCtx.putImageData(imageData, 0, 0);

                    // Apply a soft blur before compositing
                    ctx.clearRect(0, 0, width, height);
                    ctx.globalAlpha = 1;
                    ctx.drawImage(offscreenCanvas, 0, 0);

                    // Overlay blurred glow layer
                    ctx.globalAlpha = 0.2;
                    ctx.filter = 'blur(8px)';
                    ctx.drawImage(offscreenCanvas, 0, 0);

                    // Reset effects
                    ctx.globalAlpha = 1.0;
                    ctx.filter = 'none';

                    if (document.getElementById("grainToggle").checked) {
                        applyGrainOverlay(ctx, width, height);
                    }

                    originalImageData = new ImageData(
                        new Uint8ClampedArray(imageData.data),
                        imageData.width,
                        imageData.height
                    );

                    status.innerText = "✅ Complete";
                    status.className = "status complete";


                    setTimeout(() => {
                        status.innerText = "💤 Idle";
                        status.className = "status idle";
                        generateBtn.disabled = false;
                    }, 500);

                    renderTask = null;


                }
            }
            renderTask = renderChunk;
            requestAnimationFrame(renderChunk);
        }
        function adjustColorBoosts() {
            if (!originalImageData) return;

            const boostR = parseFloat(document.getElementById("boostR").value);
            const boostG = parseFloat(document.getElementById("boostG").value);
            const boostB = parseFloat(document.getElementById("boostB").value);

            const width = originalImageData.width;
            const height = originalImageData.height;

            const originalData = originalImageData.data;
            const newImageData = ctx.createImageData(width, height);
            const newData = newImageData.data;

            for (let i = 0; i < originalData.length; i += 4) {
                newData[i] = Math.min(255, originalData[i] * boostR);     // R
                newData[i + 1] = Math.min(255, originalData[i + 1] * boostG); // G
                newData[i + 2] = Math.min(255, originalData[i + 2] * boostB); // B
                newData[i + 3] = originalData[i + 3];                         // A
            }

            ctx.putImageData(newImageData, 0, 0);
        }

        function updateLightingEffect(lightAngle) {
            if (!originalImageData) return;

            const width = originalImageData.width;
            const height = originalImageData.height;

            const data = originalImageData.data;
            const newImageData = ctx.createImageData(width, height);
            const newData = newImageData.data;

            const highlightStrength = parseFloat(document.getElementById("highlightStrength").value);

            const lightVec = {
                x: Math.cos(lightAngle * 2 * Math.PI),
                y: Math.sin(lightAngle * 2 * Math.PI)
            };

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;

                    const nx = x / width - 0.5;
                    const ny = y / height - 0.5;
                    const bandFreq = 10;
                    const band = Math.sin((nx * lightVec.y - ny * lightVec.x) * bandFreq * Math.PI);
                    const highlight = band * highlightStrength;

                    newData[i] = Math.min(255, data[i] + highlight * 255);
                    newData[i + 1] = Math.min(255, data[i + 1] + highlight * 255);
                    newData[i + 2] = Math.min(255, data[i + 2] + highlight * 255);
                    newData[i + 3] = data[i + 3];
                }
            }

            ctx.putImageData(newImageData, 0, 0);
        }

        function exportPNG() {
            const link = document.createElement("a");
            link.download = "mother_of_pearl.png";
            link.href = canvas.toDataURL("image/png");
            link.click();
        }

        document.addEventListener("DOMContentLoaded", () => {
            startGeneration();
        });
    </script>
</body>

</html>
